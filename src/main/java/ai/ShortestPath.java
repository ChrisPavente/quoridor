package ai;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import board.Board;
import board.Player;
import board.Square;


/**
 * This class generates the shortest path between a player and their win location on the board. 
 */
public class ShortestPath {
	private ArrayList<Square> path; // shortest known path generated
	private Player player; // the owner of the shortest path
	private boolean byPos; // if desired destination is different than the win location designate this by true
	private Board board;

	/**
	 * Constructs a shortest path from a given player on the board's square.
	 * 
	 * @param bd: the current state of the board
	 * @param curPlay: the player we are generating the path for
	 * @param sqr:  the destination of this path, if using player's win condition this is null 
	 * @param players: the players currently in the game
	 */
	public ShortestPath(Board bd, Player curPlay, Square sqr, List<Player> players) {
		path = null;
		player = curPlay;
		byPos = sqr != null; //if desired location is given this is true
		board = bd;
		List<Square> possibleMoves = board.nextPossibleValidMove(player.getSquare()); //list of next legal move available for the current player
		ArrayList<ArrayList<Square>> paths = new ArrayList<ArrayList<Square>>();
		for(Square s : possibleMoves)
			paths.add(genPath(s, sqr));
	}

	/**
	 * Generates the shortest path.
	 * 
	 * @param curSqr: the current square of the player
	 * @param finalSqr: the win state or final destination of the player
	 * @return the squares in the shortest path
	 */
	private ArrayList<Square> genPath(Square curSqr, Square finalSqr) {
		Node<Square> current = new Node<Square>(curSqr, null);
		Square[] winningSquares = player.getWinningSquares();
		if(byPos) {
		    if(current.getData().equals(finalSqr))
		        return current.getPathToRoot();
		} else
			for(int i = 0; i < winningSquares.length; i++)
				if(current.getData().equals(winningSquares[i]))
					return current.getPathToRoot();
		Queue<Node<Square>> nodes = new LinkedList<Node<Square>>();
		nodes.add(current);
		do {
			current = nodes.remove();
			current.addChild(new Square(current.getData().getColumn() + 1, current.getData().getRow()));
	        current.addChild(new Square(current.getData().getColumn(), current.getData().getRow() + 1));
	        current.addChild(new Square(current.getData().getColumn() - 1, current.getData().getRow()));
	        current.addChild(new Square(current.getData().getColumn(), current.getData().getRow() - 1));
	        Iterator<Node<Square>> itr = current.getChildren().iterator();
	        //check for valid node
	        while(itr.hasNext()) {
	            Node<Square> pos = itr.next();
	            if(pos.getData().getColumn() < 0 || pos.getData().getRow() < 0
	                    || pos.getData().getColumn() > 8 || pos.getData().getRow() > 8)
	                itr.remove();
	        }
	        nodes.addAll(current.getChildren());
	        for(Node<Square> pos : current.getChildren())
	            if(byPos) {
	                if(pos.getData().equals(finalSqr))
	                    return pos.getPathToRoot();
	            } else
	            	for(int i = 0; i < winningSquares.length; i++)
	    				if(current.getData().equals(winningSquares[i]))
	    					return current.getPathToRoot();
			} while(!nodes.isEmpty());
		return null;
	}
	
	/**
	 * Helper method to allow a call to acquire the shortest path for a player
	 * 
	 * @return The path generated by this algorithm.
	 */
	public ArrayList<Square> getPath() {
		return path;
	}

}

/**
 * Inner class
 * A node in a tree.  Implements shortest path.
 *
 * @param <T> Data in the given node of the tree.
 */
class Node<T> {

	private T data; //node's data, ie the square of the player
	private Node<T> parent; // parent of the given node
	private ArrayList<Node<T>> children; // children of the given node

	/**
	 * Constructor to create a new node with given square and parent.
	 * 
	 * @param data: square this node represents.
	 * @param parent: parent of this node.
	 */
	public Node(T data, Node<T> parent) {
		this.data = data;
		this.parent = parent;
		children = new ArrayList<Node<T>>();
	}

	/**
	 * Allows the addition of a child to the given node. Making the given node a parent.
	 * 
	 * @param child: the node to be added to the given node
	 */
	public void addChild(T child) {
		if(!contains(new Node<T>(child, null))) {
			children.add(new Node<T>(child, this));
		}
	}

	/**
	 * Removes a child from the given node.
	 * 
	 * @param child: node to be removed.
	 */
	public void removeChild(Node<T> child) {
		children.remove(child);
	}

	/**
	 * Gets the parent of this node.
	 * 
	 * @return The parent of this node.
	 */
	public Node<T> getParent() {
		return parent;
	}

	/**
	 * Gets the list of children of this node.
	 * 
	 * @return The list of children of this node.
	 */
	public ArrayList<Node<T>> getChildren() {
		return children;
	}

	/**
	 * Returns the data stored in this node.
	 * 
	 * @return The data in this node.
	 */
	public T getData() {
		return data;
	}

	/**
	 * Creates a list of nodes generated by the path-finding algorithm from the given
	 * node to the root of the tree.
	 * 
	 * @return The list of traversal to the root.
	 */
	public ArrayList<T> getPathToRoot() {
		Node<T> current = this;
		ArrayList<T> path = new ArrayList<T>();
		while(current != null) {
			path.add(current.getData());
			current = current.getParent();
		}
		Collections.reverse(path);
		return path;
	}


	@SuppressWarnings("unchecked")
    public boolean equals(Object o) {
		if(!o.getClass().equals(this.getClass()))
			return false;
		return data.equals(((Node<T>) o).data);
	}

	/**
	 * Determines if the given node is a parent in the tree of the current node.
	 * 
	 * @param node: the node we are checking for parental information from
	 * @return True if the given node is a parent, false otherwise
	 */
	public boolean contains(Node<T> node) {
		Node<T> current = this;
		int count = 0;
		while(current.getParent() != null) {
			count++;
			current = current.getParent();
		}
		Node<T> n = containsRecurse(current, node);
		if(n == null)
			return false;
		while(n.getParent() != null) {
			count--;
			n = n.getParent();
		}
		return count >= -1;
	}

    /**
     * Determines if the given node is a parent in the subtree this node belongs to.
     * 
     * @param root: root of the subtree for consideration.
     * @param node: node we are checking for parental information from.
     * @return true if the given node is a parent, false otherwise.
     */
	public Node<T> containsRecurse(Node<T> root, Node<T> node) {
		if(root.children.isEmpty() && !root.equals(node))
			return null;
		if(root.equals(node))
			return root;
		for(Node<T> n : root.getChildren()){
			Node<T> no = containsRecurse(n, node);
			if(no != null)
				return no;
		}	
		return null;
	}


	public String toString() {
		return data.toString() + (children.isEmpty() ? "" :
		    children.toString());
	}

}
